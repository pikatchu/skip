# Copyright (c) Facebook, Inc. and its affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

# This is used to make sure that all the children die when the script ends.
# Which is what we want, if nobody is listening on the fifos, what's the point
# in having a background skip_server waiting for commands?

trap 'kill 0' EXIT

# The path of the directory that we are trying to work with.
# We use realpath to make sure the path is normalized.

root=`realpath "$1"`

if ! [ -d "$root" ] ; then
    echo "$root is not a directory"
    exit 1
fi

# This is a scheme to create a unique temporary file name derived
# from the directory named. We first replace the 'z' with "zZ" and
# then replace the '/' with z. This way, for example, the directory
# /tmp/myDirwithZinIt becomes ztmpzmyDirwithzZinIt.
# The idea is to create a valid filename given an absolute path.

skdir_escape_z="${root//z/zZ}"
tmpdir=$(dirname $(mktemp -u))
skdir="$tmpdir/.skserver_${skdir_escape_z//\//z}"

trap "rm -f \"$skdir\"" EXIT

if ! [ -e "$skdir" ] ; then
    mkdir "$skdir"
fi

# The lock mechanism we use is incorrect, but it's ok.
# The scheme we use consists in touching the file called "lock" when
# running and then remove the file on exit. This is incorrect, because we
# could have died in an ungraceful way. Which means it is possible to have a lock
# file without a running server. However, that situation going to be rare, and
# easy to fix. I added a message that says to remove 'skdir' if the user think
# something fishy is going on.
#
# N.B.: I am aware of lockfile, but I thought it was a bit of an overkill to
# depend on procmail just for that. Of course, that's debatable.

if [ -f  "$skdir/lock" ] ; then
    echo "Server already running";
    echo "If you don't think that should be the case: $ rm -Rf \"$skdir\""
    exit 2
fi

# This is obviously a race as well. See commend above.
touch "$skdir/lock"
trap "rm \"$skdir/lock\"" EXIT

# We use 2 fifos to talk to the skip_server.
fifo_command="$skdir/fifo_command"
fifo_response="$skdir/fifo_response"
rm -f "$fifo_command"
rm -f "$fifo_response"
mkfifo "$fifo_command"
mkfifo "$fifo_response"

read -r < "$fifo_response"&

"$skip_server" "$root" --export-function-as main=skip_main \
	     --output "$skdir/out.ll" < "$fifo_command" > "$fifo_response" \
	     2> "$skdir/server_errors" &

# To make sure the fifos do not close.
# The server will die every 24 hours, but that's ok.
sleep 86400 > "$fifo_command" < "$fifo_response"
